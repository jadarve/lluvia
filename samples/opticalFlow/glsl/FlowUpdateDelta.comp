#version 450

#include <lluvia/core.glsl>

layout(binding = 0, r32f)  uniform image2D in_gray;
layout(binding = 1, rg32f) uniform image2D in_gradient;
layout(binding = 2, rg32f) uniform image2D in_delta_flow;
layout(binding = 3, r32f)  uniform image2D in_gray_old;

// input flow from level above. This has half the resolution of the other parameters.
layout(binding = 4) uniform sampler2D in_flow;

layout(binding = 5, r32f) uniform image2D out_gray;
layout(binding = 6, rg32f) uniform image2D out_flow;
layout(binding = 7, rg32f) uniform image2D out_delta_flow;

layout(push_constant) uniform const_0 {
    float gamma;
    float maxflow;
} params;


void main() {

    const float gamma = params.gamma;
    const float maxflow = params.maxflow;

    // this coordinates are relative to out_gradient size
    const ivec2 coords  = LL_GLOBAL_COORDS_2D;
    const ivec2 imgSize = imageSize(in_gray);

    if (coords.x > imgSize.x || coords.y > imgSize.y) {
        return;
    }

    const float gray = imageLoad(in_gray, coords).r;
    const float gray_old = imageLoad(in_gray_old, coords).r;
    const vec2 gray_gradient = imageLoad(in_gradient, coords).xy;

    const vec2 delta_flow_old = imageLoad(in_delta_flow, coords).xy;

    //#################################
    // Delta flow computation
    //#################################
    // temporal derivative
    const float gray_dt = gray_old - gray;
    
    // squared gradient
    const vec2 grad_square = gray_gradient * gray_gradient;

    // Adjunt matrix
    const float diag_off = gray_gradient.x * gray_gradient.y;
    const mat2 M = mat2(gamma + grad_square.y, -diag_off, -diag_off, gamma + grad_square.x);

    // reciprocal determinand of M
    const float rdet = 1.0f / (gamma * (gamma + grad_square.x + grad_square.y));

    const vec2 q = (gamma * delta_flow_old) + (gray_dt * gray_gradient);

    vec2 delta_flow_new = rdet * (M * q);

    // truncate
    // FIXME: possibly truncation and sanitation can happen on flow_new
    delta_flow_new.x = max(-maxflow, min(delta_flow_new.x, maxflow));
    delta_flow_new.y = max(-maxflow, min(delta_flow_new.y, maxflow));

    // sanitize
    delta_flow_new.x = isinf(delta_flow_new.x) || isnan(delta_flow_new.x)? 0.0f : delta_flow_new.x;
    delta_flow_new.y = isinf(delta_flow_new.y) || isnan(delta_flow_new.y)? 0.0f : delta_flow_new.y;

    //#################################
    // Optical flow computation
    //#################################
    // normalized coordinates
    const vec2 flowUpCoords = vec2(coords.x / (imgSize.x - 1.0), coords.y / (imgSize.y - 1.0));
    
    const vec2 flow_old = 2.0 * texture(in_flow, flowUpCoords).xy;

    vec2 flow_new = flow_old + delta_flow_new;
    
    // truncate
    flow_new.x = max(-maxflow, min(flow_new.x, maxflow));
    flow_new.y = max(-maxflow, min(flow_new.y, maxflow));

    // sanitize
    flow_new.x = isinf(flow_new.x) || isnan(flow_new.x)? 0.0f : flow_new.x;
    flow_new.y = isinf(flow_new.y) || isnan(flow_new.y)? 0.0f : flow_new.y;

    imageStore(out_flow, coords, vec4(flow_new.x, flow_new.y, 0, 0));
    imageStore(out_gray, coords, vec4(gray));
    imageStore(out_delta_flow, coords, vec4(delta_flow_new.x, delta_flow_new.y, 0, 0));
}
